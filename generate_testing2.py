# Copyright (c) 2023 MikoÅ‚aj Kuranowski
# SPDX-License-Identifier: MIT

import sys
from pathlib import Path
from typing import IO


def parse_cli_arguments() -> str:
    if len(sys.argv) != 2:
        sys.exit(f"Usage: python3 {sys.argv[0]} <package_name>")

    package_name = sys.argv[1]

    if package_name not in {"assert", "check"}:
        sys.exit(
            f"Invalid package name, got: {package_name!r}, expected 'assert' or 'check'"
        )

    return package_name


def generate_header(f: IO[str], package_name: str) -> None:
    f.writelines(
        (
            "// Code generated by generate_testing2.py. DO NOT EDIT.\n",
            "\n",
            f"package {package_name}\n",
            "\n",
            "import (\n",
            '\t"errors"\n',
            '\t"math"\n',
            '\t"reflect"\n',
            '\t"testing"\n',
            "\n",
            '\t"golang.org/x/exp/constraints"\n',
            ")\n",
            "\n",
        )
    )


def generate_generic_test(
    f: IO[str],
    name: str,
    type_constraint: str,
    failure_condition: str,
    fail_method: str,
) -> None:
    f.writelines(
        (
            f"func {name}[T {type_constraint}](t *testing.T, got, expected T) {{\n",
            f"\tif {failure_condition} {{\n",
            f'\t\tt.{fail_method}f("got: %v, expected: %v", got, expected)\n',
            "\t}\n",
            "}\n",
            "\n",
            f"func {name}Msg[T {type_constraint}](t *testing.T, got, expected T, msg string) {{\n",
            f"\tif {failure_condition} {{\n",
            f'\t\tt.{fail_method}f("%s: got: %v, expected: %v", msg, got, expected)\n',
            "\t}\n",
            "}\n",
            "\n",
        )
    )


def generate_concrete_test(
    f: IO[str],
    name: str,
    type: str,
    failure_condition: str,
    fail_method: str,
) -> None:
    f.writelines(
        (
            f"func {name}(t *testing.T, got, expected {type}) {{\n",
            f"\tif {failure_condition} {{\n",
            f'\t\tt.{fail_method}f("got: %v, expected: %v", got, expected)\n',
            "\t}\n",
            "}\n",
            "\n",
            f"func {name}Msg(t *testing.T, got, expected {type}, msg string) {{\n",
            f"\tif {failure_condition} {{\n",
            f'\t\tt.{fail_method}f("%s: got: %v, expected: %v", msg, got, expected)\n',
            "\t}\n",
            "}\n",
            "\n",
        )
    )


def generate_concrete_test_with_single_arg(
    f: IO[str],
    name: str,
    type: str,
    failure_condition: str,
    expected_literal: str,
    fail_method: str,
) -> None:
    f.writelines(
        (
            f"func {name}(t *testing.T, got {type}) {{\n",
            f"\tif {failure_condition} {{\n",
            f'\t\tt.{fail_method}f("got: %v, expected: %v", got, {expected_literal})\n',
            "\t}\n",
            "}\n",
            "\n",
            f"func {name}Msg(t *testing.T, got {type}, msg string) {{\n",
            f"\tif {failure_condition} {{\n",
            f'\t\tt.{fail_method}f("%s: got: %v, expected: %v", msg, got, {expected_literal})\n',
            "\t}\n",
            "}\n",
            "\n",
        )
    )


def generate_bool_tests(f: IO[str], fail_method: str) -> None:
    generate_concrete_test_with_single_arg(
        f,
        name="True",
        type="bool",
        failure_condition="!got",
        expected_literal="true",
        fail_method=fail_method,
    )
    generate_concrete_test_with_single_arg(
        f,
        name="False",
        type="bool",
        failure_condition="got",
        expected_literal="false",
        fail_method=fail_method,
    )


def generate_error_tests(f: IO[str], fail_method: str) -> None:
    generate_concrete_test_with_single_arg(
        f,
        name="Err",
        type="error",
        failure_condition="got == nil",
        expected_literal='"non-nil"',
        fail_method=fail_method,
    )
    generate_concrete_test_with_single_arg(
        f,
        name="NoErr",
        type="error",
        failure_condition="got != nil",
        expected_literal="nil",
        fail_method=fail_method,
    )
    generate_concrete_test(
        f,
        name="SpecificErr",
        type="error",
        failure_condition="!errors.Is(got, expected)",
        fail_method=fail_method,
    )


def generate_deep_equal_tests(f: IO[str], fail_method: str) -> None:
    generate_concrete_test(
        f,
        name="DeepEq",
        type="any",
        failure_condition="!reflect.DeepEqual(got, expected)",
        fail_method=fail_method,
    )


def generate_equal_tests(f: IO[str], fail_method: str) -> None:
    generate_generic_test(
        f,
        name="Eq",
        type_constraint="comparable",
        failure_condition="!(got == expected)",
        fail_method=fail_method,
    )
    generate_generic_test(
        f,
        name="Ne",
        type_constraint="comparable",
        failure_condition="!(got != expected)",
        fail_method=fail_method,
    )


ORDER_OPERATORS = [("<", "Lt"), ("<=", "Le"), (">", "Gt"), (">=", "Ge")]


def generate_ordered_tests(f: IO[str], fail_method: str) -> None:
    for op, name in ORDER_OPERATORS:
        f.writelines(
            (
                f"func {name}[T constraints.Ordered](t *testing.T, a, b T) {{\n",
                f"\tif !(a {op} b) {{\n",
                f'\t\tt.{fail_method}f("expected: %v {op} %v", a, b)\n',
                "\t}\n",
                "}\n",
                "\n",
                f"func {name}Msg[T constraints.Ordered](t *testing.T, a, b T, msg string) {{\n",
                f"\tif !(a {op} b) {{\n",
                f'\t\tt.{fail_method}f("%s: expected: %v {op} %v", msg, a, b)\n',
                "\t}\n",
                "}\n",
                "\n",
            )
        )


def generate_float_tests(f: IO[str], fail_method: str) -> None:
    f.writelines(
        (
            f"func Close(t *testing.T, a, b, delta float64) {{\n",
            "\tdiff := math.Abs(b - a)\n",
            f"\tif diff > delta {{\n",
            f'\t\tt.{fail_method}f("expected %v and %v to be within %v, got: %v", a, b, delta, diff)\n',
            "\t}\n",
            "}\n",
            "\n",
            f"func CloseMsg(t *testing.T, a, b, delta float64, msg string) {{\n",
            "\tdiff := math.Abs(b - a)\n",
            f"\tif diff > delta {{\n",
            f'\t\tt.{fail_method}f("%s: expected %v and %v to be within %v, got: %v", msg, a, b, delta, diff)\n',
            "\t}\n",
            "}\n",
            "\n",
        )
    )

    generate_concrete_test_with_single_arg(
        f,
        name="NaN",
        type="float64",
        failure_condition="!math.IsNaN(got)",
        expected_literal='"NaN"',
        fail_method=fail_method,
    )

    generate_concrete_test_with_single_arg(
        f,
        name="NotNaN",
        type="float64",
        failure_condition="math.IsNaN(got)",
        expected_literal='"not-NaN"',
        fail_method=fail_method,
    )

    generate_concrete_test_with_single_arg(
        f,
        name="Inf",
        type="float64",
        failure_condition="!math.IsInf(got, 0)",
        expected_literal='"Inf"',
        fail_method=fail_method,
    )

    generate_concrete_test_with_single_arg(
        f,
        name="NotInf",
        type="float64",
        failure_condition="math.IsInf(got, 0)",
        expected_literal='"not-Inf"',
        fail_method=fail_method,
    )

    generate_concrete_test_with_single_arg(
        f,
        name="Normal",
        type="float64",
        failure_condition="math.IsNaN(got) || math.IsInf(got, 0)",
        expected_literal='"NaN or Inf"',
        fail_method=fail_method,
    )

    generate_concrete_test_with_single_arg(
        f,
        name="NotNormal",
        type="float64",
        failure_condition="!math.IsNaN(got) && !math.IsInf(got, 0)",
        expected_literal='"not NaN nor Inf"',
        fail_method=fail_method,
    )


TEST_GENERATORS = [
    generate_bool_tests,
    generate_error_tests,
    generate_deep_equal_tests,
    generate_equal_tests,
    generate_ordered_tests,
    generate_float_tests
]


def main() -> None:
    package_name = parse_cli_arguments()
    fail_method = "Fatal" if package_name == "assert" else "Error"
    output_file = Path.cwd() / f"{package_name}_generated.go"

    print(output_file)

    with output_file.open(mode="w", encoding="ascii", newline="\n") as f:
        generate_header(f, package_name)
        for generator in TEST_GENERATORS:
            generator(f, fail_method)


if __name__ == "__main__":
    main()
