// Copyright (c) 2023 Mikołaj Kuranowski
// SPDX-License-Identifier: MIT

package iter

import (
	"fmt"
	"math/bits"

	"golang.org/x/exp/constraints"
	"golang.org/x/exp/slices"
)

type deepIterState uint8

const (
	deepIterStateNotStarted deepIterState = iota
	deepIterStateNextGroup
	deepIterStateInGroup
	deepIterStateEndGroup
	deepIterStateFinished
)

type chainIterator[T any] struct {
	its     Iterator[Iterator[T]]
	current Iterator[T]
	err     error
	done    bool
}

func (i *chainIterator[T]) Next() bool {
	if i.done {
		return false
	}

	for !i.done {
		// Move to next iterator
		if i.current == nil {
			if i.its.Next() {
				i.current = i.its.Get()
			} else {
				i.err = i.its.Err()
				i.done = true
				break
			}
		}

		// Try to get an element from current iterator
		if i.current.Next() {
			return true
		} else if i.err = i.current.Err(); i.err != nil {
			i.done = true
			return false
		} else {
			i.current = nil
		}
	}

	return false
}

func (i *chainIterator[T]) Get() T     { return i.current.Get() }
func (i *chainIterator[T]) Err() error { return i.err }

// Chain returns all elements from the provided iterators, in order.
// Also called "Flatten" in other languages.
//
//	Chain([1 2], [3 4], [5 6]) → [1 2 3 4 5 6]
//
// See also [ChainFromIterator], which lazily retrieves next iterators.
func Chain[T any](its ...Iterator[T]) Iterator[T] {
	return &chainIterator[T]{its: OverSlice(its)}
}

// ChainFromIterator returns all elements from all iterators generated by `its`.
// As opposed to [Chain], next iterator are retrieved lazily, which allows
// an infinite number of inner iterators.
//
//	ChainFromIterator([[1 2] [3 4] [5 6]]) → [1 2 3 4 5 6]
//
// See also [Chain], which explicitly takes iterators to chain together.
func ChainFromIterator[T any](its Iterator[Iterator[T]]) Iterator[T] {
	return &chainIterator[T]{its: its}
}

type chainMapIterator[T, U any] struct {
	i Iterator[T]
	f func(T) Iterator[U]

	err     error
	current Iterator[U]
}

func (i *chainMapIterator[T, U]) Next() bool {
	for {
		// Try to get the next sub-iterator, if the current one was exhausted.
		if i.current == nil {
			if i.i.Next() {
				i.current = i.f(i.i.Get())
			} else {
				i.err = i.i.Err()
				return false
			}
		}

		// Try to get an element from the sub-iterator, also handling errors from it.
		if i.current.Next() {
			return true
		} else if i.err = i.i.Err(); i.err != nil {
			return false
		} else {
			i.current = nil
		}
	}
}

func (i *chainMapIterator[T, U]) Get() U {
	return i.current.Get()
}

func (i *chainMapIterator[T, U]) Err() error {
	return i.err
}

// ChainMap is an implementation of 2 operations: [Map], then [Chain];
// returns all values returned from iterators returned by calling f on every element of i.
//
//	ChainMap([1 5 10], x => [x, x + 2]) → [1 3 5 7 10 12]
func ChainMap[T, U any](i Iterator[T], f func(T) Iterator[U]) Iterator[U] {
	return &chainMapIterator[T, U]{i: i, f: f}
}

type compressIterator[T, U any] struct {
	i         Iterator[T]
	selectors Iterator[U]
	pred      func(U) bool
}

func (i *compressIterator[T, U]) Next() bool {
	for i.i.Next() {
		if !i.selectors.Next() {
			return false
		}

		if i.pred(i.selectors.Get()) {
			return true
		}
	}

	return false
}

func (i *compressIterator[T, U]) Get() T { return i.i.Get() }

func (i *compressIterator[T, U]) Err() error {
	var err error
	if err = i.i.Err(); err != nil {
		return err
	}
	if err = i.selectors.Err(); err != nil {
		return err
	}
	return nil
}

// Compress returns elements from i, for which the corresponding element
// from selectors is true.
//
// Functionally equivalent to [Pairwise] + [Filter], while also discarding the selector.
//
//	Compress([1 2 3 4], [true false true false]) → [1 3]
//
// See also the [CompressFunc] function.
func Compress[T any](i Iterator[T], selectors Iterator[bool]) Iterator[T] {
	return &compressIterator[T, bool]{
		i:         i,
		selectors: selectors,
		pred:      func(x bool) bool { return x },
	}
}

// CompressFunc returns elements from i, if calling predicate on the corresponding element
// from selectors returns true.
//
// Similar functionally may be achieved with [Pairwise] + [Filter],
// while also discarding the selector.
//
//	CompressFunc(["a" "b" "c" "d"], [1, 2, 3, 4], isEven) → ["b" "d"]
//
// See [Compress], if selectors is already an iterator of booleans.
func CompressFunc[T, U any](i Iterator[T], selectors Iterator[U], pred func(U) bool) Iterator[T] {
	return &compressIterator[T, U]{
		i:         i,
		selectors: selectors,
		pred:      pred,
	}
}

type consecutivePairsIterator[T any] struct {
	i       Iterator[T]
	p, c    T
	hasElem bool
}

func (i *consecutivePairsIterator[T]) Next() bool {
	// Get the very first element
	if !i.hasElem {
		if i.i.Next() {
			i.c = i.i.Get()
			i.hasElem = true
		} else {
			return false
		}
	}

	// Get the current element
	if !i.i.Next() {
		return false
	}
	i.p, i.c = i.c, i.i.Get()
	return true
}

func (i *consecutivePairsIterator[T]) Get() [2]T  { return [2]T{i.p, i.c} }
func (i *consecutivePairsIterator[T]) Err() error { return i.i.Err() }

// ConsecutivePairs generates successive overlapping pairs of elements from the iterator.
//
//	ConsecutivePairs([1 2 3 4]) → [[1 2] [2 3] [3 4]]
//	ConsecutivePairs([1]) → []
//	ConsecutivePairs([]) → []
func ConsecutivePairs[T any](i Iterator[T]) Iterator[[2]T] {
	return &consecutivePairsIterator[T]{i: i}
}

type groupByIterator[T, K any] struct {
	i   Iterator[T]
	key func(T) K
	eq  func(K, K) bool

	e     T
	k     K
	err   error
	state deepIterState
}

func (i *groupByIterator[T, K]) onEnd() bool {
	i.err = i.i.Err()
	i.state = deepIterStateFinished
	return false
}

func (i *groupByIterator[T, K]) Next() bool {
	switch i.state {

	case deepIterStateNotStarted:
		// unconditionally start next group
		if i.i.Next() {
			i.e = i.i.Get()
			i.k = i.key(i.e)
			i.state = deepIterStateNextGroup
			return true
		} else {
			return i.onEnd()
		}

	case deepIterStateNextGroup, deepIterStateInGroup:
		// find the start of next group
		for i.i.Next() {
			i.e = i.i.Get()
			elemKey := i.key(i.e)
			if !i.eq(elemKey, i.k) {
				i.k = elemKey
				i.state = deepIterStateNextGroup
				return true
			}
		}

		// no next group - end
		return i.onEnd()

	case deepIterStateEndGroup:
		// grouper has encountered a different key and advanced to it
		i.state = deepIterStateNextGroup
		return true

	case deepIterStateFinished:
		// nothing to do - already exhausted
		return false

	default:
		panic(fmt.Sprintf("invalid groupByIterator state: %d", i.state))
	}
}

func (i *groupByIterator[T, K]) Get() Pair[K, Iterator[T]] {
	return Pair[K, Iterator[T]]{i.k, &groupByGrouper[T, K]{i}}
}

func (i *groupByIterator[T, K]) nextInGroup() bool {
	switch i.state {
	case deepIterStateNotStarted:
		panic("groupByGrouper.Next() called before groupByIterator.Next()")

	case deepIterStateNextGroup:
		// just entered a new group - return the new key
		i.state = deepIterStateInGroup
		return true

	case deepIterStateInGroup:
		if i.i.Next() {
			i.e = i.i.Get()
			elemKey := i.key(i.e)
			if !i.eq(elemKey, i.k) {
				// new key seen - advance to next group
				i.k = elemKey
				i.state = deepIterStateEndGroup
				return false // no more elements in this group
			}

			i.state = deepIterStateInGroup
			return true

		} else {
			return i.onEnd()
		}

	case deepIterStateEndGroup, deepIterStateFinished:
		// group already exhausted - nothing more to generate
		return false

	default:
		panic(fmt.Sprintf("invalid deepIteratorState state: %d", i.state))
	}
}

func (i *groupByIterator[T, K]) getInGroup() T { return i.e }

func (i *groupByIterator[T, K]) Err() error { return i.err }

type groupByGrouper[T, K any] struct{ i *groupByIterator[T, K] }

func (g *groupByGrouper[T, K]) Next() bool { return g.i.nextInGroup() }
func (g *groupByGrouper[T, K]) Get() T     { return g.i.getInGroup() }
func (g *groupByGrouper[T, K]) Err() error { return g.i.Err() }

// GroupBy generates consecutive runs of elements for which `key(elem)` is the same.
//
// If a consecutive run for a particular key should be generated only once,
// ensure the input is sorted by the key function. This differs from SQL's GROUP BY construct -
// this function behaves like the POSIX `uniq` utility.
//
// The group iterator is shared with the GroupBy iterator, so a group is no longer available
// after advancing to the next key.
//
//	names := ["Alice" "Adam" "Amelia" "Andrew" "Bob" "Brian" "Casey" "Chloe" "Craig"]
//	GroupBy(names, name => name[0])
//	→ [{"A" ["Alice" "Adam" "Amelia" "Andrew"]} {"B" ["Bob" "Brian"]} {"C" ["Casey" "Chloe" "Craig"]}]
//
//	names := ["Alice" "Andrew" "Bob" "Casey" "Adam" "Amelia" "Chloe" "Craig" "Brian"]
//	GroupBy(names, name => name[0])
//	→ [{"A" ["Alice" "Andrew"]} {"B" ["Bob"]} {"C" ["Casey"]} {"A" ["Adam" "Amelia"]} {"C" ["Chloe" "Craig"]} {"B" ["Brian"]}]
//
// See [GroupByFunc], for a function allowing custom key comparisons.
func GroupBy[T any, K comparable](i Iterator[T], key func(T) K) Iterator[Pair[K, Iterator[T]]] {
	return &groupByIterator[T, K]{
		i:   i,
		key: key,
		eq:  func(k1, k2 K) bool { return k1 == k2 },
	}
}

// GroupByFunc generates consecutive runs of elements for which `eq(key(elem1), key(elem2))` is true.
//
// If a consecutive run for a particular key should be generated only once,
// ensure the input is sorted by the key function. This differs from SQL's GROUP BY construct -
// this function behaves like the POSIX `uniq` utility.
//
// The group iterator is shared with the GroupByFunc iterator, so a group is no longer available
// after advancing to the next key.
//
// See [GroupBy] if K is already comparable.
func GroupByFunc[T, K any](i Iterator[T], key func(T) K, eq func(K, K) bool) Iterator[Pair[K, Iterator[T]]] {
	return &groupByIterator[T, K]{i: i, key: key, eq: eq}
}

type pairwiseIterator[T, U any] struct {
	ts Iterator[T]
	us Iterator[U]
}

func (i *pairwiseIterator[T, U]) Next() bool {
	if !i.ts.Next() {
		return false
	}

	if !i.us.Next() {
		return false
	}

	return true
}

func (i *pairwiseIterator[T, U]) Get() Pair[T, U] {
	return Pair[T, U]{i.ts.Get(), i.us.Get()}
}

func (i *pairwiseIterator[T, U]) Err() error {
	var err error
	if err = i.ts.Err(); err != nil {
		return err
	}
	if err = i.us.Err(); err != nil {
		return err
	}
	return nil
}

// Pairwise returns pairs of corresponding elements from ts and us.
//
// Stops once any of the iterators is exhausted.
//
//	Pairwise([1 2 3], ["a" "b" "c"]) → [{1 "a"} {2 "b"} {3 "c"}]
//	Pairwise([1 2 3], ["a"]) → [{1 "a"}]
//	Pairwise([], ["a" "b"]) → []
//
// See [Zip] for a similar operation on an arbitrary number of homogenous iterators, or
// [PairwiseLongest] for an operation which stops only when all iterators are exhausted
// (and does not short-circuit).
//
// This function short-circuits and may not exhaust the provided iterator.
func Pairwise[T, U any](ts Iterator[T], us Iterator[U]) Iterator[Pair[T, U]] {
	return &pairwiseIterator[T, U]{ts: ts, us: us}
}

type pairwiseLongestIterator[T, U any] struct {
	ts Iterator[T]
	us Iterator[U]

	tFill T
	uFill U

	tDone, uDone bool
}

func (i *pairwiseLongestIterator[T, U]) getT() T {
	if i.tDone {
		return i.tFill
	}
	return i.ts.Get()
}

func (i *pairwiseLongestIterator[T, U]) getU() U {
	if i.uDone {
		return i.uFill
	}
	return i.us.Get()
}

func (i *pairwiseLongestIterator[T, U]) Next() bool {
	// Advance the T iterator
	if !i.tDone {
		i.tDone = !i.ts.Next()
	}

	// Advance the U iterator
	if !i.uDone {
		i.uDone = !i.us.Next()
	}

	return !i.tDone || !i.uDone
}

func (i *pairwiseLongestIterator[T, U]) Get() Pair[T, U] {
	return Pair[T, U]{i.getT(), i.getU()}
}

func (i *pairwiseLongestIterator[T, U]) Err() error {
	if err := i.ts.Err(); err != nil {
		return err
	}
	if err := i.us.Err(); err != nil {
		return err
	}
	return nil
}

// PairwiseLongest returns pairs of corresponding elements from ts and us.
//
// Stops once both of the iterators are exhausted, even if one of the iterators
// returns an error.
//
// If there are different amount of elements in the provided iterators,
// uses tFill or uFill values in place of the exhausted iterator's elements.
//
//	PairwiseLongest([1 2 3], ["a" "b" "c"], 0, "-") → [{1 "a"} {2 "b"} {3 "c"}]
//	PairwiseLongest([1 2 3], ["a"], 0, "-") → [{1 "a"} {2 "-"} {3 "-"}]
//	PairwiseLongest([], ["a" "b"], 0, "-") → [{0 "a"} {0 "b"}]
//	PairwiseLongest(Error(someErr), ["a" "b"], 0, "-") → [{0 "a"} {0 "b"}]
//
// See [ZipLongest] for a similar operation on an arbitrary number of homogenous iterators,
// or [Pairwise] which stops when one of the iterators is exhausted.
func PairwiseLongest[T, U any](ts Iterator[T], us Iterator[U], tFill T, uFill U) Iterator[Pair[T, U]] {
	return &pairwiseLongestIterator[T, U]{ts: ts, us: us, tFill: tFill, uFill: uFill}
}

// Sort collects all elements of an iterator into a slice,
// and the sorts it with the help of [slices.Sort].
//
// Because of the assumption made by [slices.Sort], [strict weak ordering] is required.
// Such ordering is not satisfied, e.g. when floating point NaN values are present;
// in that case use `SortFunc(x, func(a, b float64) bool {return a < b || (math.IsNaN(a) && !math.IsNaN(b))})`.
//
//	Sort([2 3 1 0]) → [0 1 2 3]
//
// [strict weak ordering]: https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings
func Sort[T constraints.Ordered](i Iterator[T]) Iterator[T] {
	s := IntoSlice(i)
	slices.Sort(s)
	return OverSlice(s)
}

// SortFunc collects all elements of an iterator into a slice,
// and the sorts it using [slices.SortFunc] with the provided comparator function.
//
// Because of the assumption made by [slices.Sort], [strict weak ordering] is required.
// Such ordering is not satisfied by the `<` operator when floating point NaN values are present;
// in that case use `func(a, b float64) bool {return a < b || (math.IsNaN(a) && !math.IsNaN(b))}`,
// as the comparator function.
//
//	people := []Person{{"Alice", 30}, {"Bob", 25}, {"Charlie", 41}}
//	SortFunc(people, p => p.age) → [{"Bob", 25}, {"Alice", 30}, {"Charlie", 41}]
//
// [strict weak ordering]: https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings
func SortFunc[T any](i Iterator[T], less func(T, T) bool) Iterator[T] {
	s := IntoSlice(i)
	slices.SortFunc(s, less)
	return OverSlice(s)
}

// SortStableFunc collects all elements of an iterator into a slice,
// and the sorts it while keeping the relative order of equal elements using [slices.SortStableFunc]
// with the provided comparator function.
//
// Because of the assumption made by [slices.Sort], [strict weak ordering] is required.
// Such ordering is not satisfied by the `<` operator when floating point NaN values are present;
// in that case use `func(a, b float64) bool {return a < b || (math.IsNaN(a) && !math.IsNaN(b))}`,
// as the comparator function.
//
// [strict weak ordering]: https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings
func SortStableFunc[T any](i Iterator[T], less func(T, T) bool) Iterator[T] {
	s := IntoSlice(i)
	slices.SortStableFunc(s, less)
	return OverSlice(s)
}

type splitOnIterator[T any] struct {
	i           Iterator[T]
	shouldSplit func(T) bool

	v     T
	err   error
	state deepIterState
}

func (i *splitOnIterator[T]) onEnd() bool {
	i.err = i.i.Err()
	i.state = deepIterStateFinished
	return false
}

func (i *splitOnIterator[T]) Next() bool {
	switch i.state {

	case deepIterStateNotStarted, deepIterStateNextGroup, deepIterStateInGroup:
		// find the start of next group
		for i.i.Next() {
			i.v = i.i.Get()
			if !i.shouldSplit(i.v) {
				i.state = deepIterStateNextGroup
				return true
			}
		}
		return i.onEnd()

	case deepIterStateEndGroup:
		// It's impossible to end a group without stepping onto an element,
		// which should be returned as part of next group.
		//
		// It nextInGroup() has encountered an element for which shouldSplit is true,
		// the transition should be made to the deepIterStateNextGroup start -
		// to start looking for the next group.
		panic("deppIteratorStateEndGroup is invalid for splitOnIterator")

	case deepIterStateFinished:
		// nothing to do - already exhausted
		return false

	default:
		panic(fmt.Sprintf("invalid deepIteratorState state: %d", i.state))
	}
}

func (i *splitOnIterator[T]) Get() Iterator[T] {
	return &splitOnInnerIterator[T]{i}
}

func (i *splitOnIterator[T]) nextInGroup() bool {
	switch i.state {
	case deepIterStateNotStarted:
		panic("splitOnInnerIterator.Next() called before splitOnIterator.Next()")

	case deepIterStateNextGroup:
		// just entered a new group - return the first element
		i.state = deepIterStateInGroup
		return true

	case deepIterStateInGroup:
		if i.i.Next() {
			i.v = i.i.Get()
			if i.shouldSplit(i.v) {
				i.state = deepIterStateNextGroup
				return false
			} else {
				return true
			}
		} else {
			return i.onEnd()
		}

	case deepIterStateEndGroup, deepIterStateFinished:
		// group already exhausted - nothing more to generate
		return false

	default:
		panic(fmt.Sprintf("invalid deepIteratorState state: %d", i.state))
	}
}

func (i *splitOnIterator[T]) getInGroup() T { return i.v }

func (i *splitOnIterator[T]) Err() error { return i.err }

type splitOnInnerIterator[T any] struct{ i *splitOnIterator[T] }

func (g *splitOnInnerIterator[T]) Next() bool { return g.i.nextInGroup() }
func (g *splitOnInnerIterator[T]) Get() T     { return g.i.getInGroup() }
func (g *splitOnInnerIterator[T]) Err() error { return g.i.Err() }

// SplitOn splits an iterator into multiple iterators, separated by
// runs of elements for which shouldSplit returns true.
//
// The inner iterator is shared with the SplitOn iterator, so the inner "words"
// are not available after calling splitOnIterator.Next().
//
// Functionally equivalent to GroupBy + Filter, while also discarding the boolean "keys".
//
//	SplitOn("foo bar baz", unicode.IsSpace) → ["foo" "bar" "baz"]
//	SplitOn("foo   bar  baz  ", unicode.IsSpace) → ["foo" "bar" "baz"]
//	SplitOn("   ", unicode.IsSpace) → []
//	SplitOn("", unicode.IsSpace) → []
func SplitOn[T any](i Iterator[T], shouldSplit func(T) bool) Iterator[Iterator[T]] {
	return &splitOnIterator[T]{i: i, shouldSplit: shouldSplit}
}

type zipIterator[T any] struct {
	its []Iterator[T]
}

func (i *zipIterator[T]) Next() bool {
	for _, it := range i.its {
		if !it.Next() {
			return false
		}
	}
	return true
}

func (i *zipIterator[T]) Get() []T {
	// TODO: Avoid allocating a slice for every call to Get
	r := make([]T, 0, len(i.its))
	for _, it := range i.its {
		r = append(r, it.Get())
	}
	return r
}

func (i *zipIterator[T]) Err() error {
	var err error
	for _, it := range i.its {
		err = it.Err()
		if err != nil {
			break
		}
	}
	return err
}

// Zip returns slices of consecutive elements from all the iterators.
//
// Stops once any of the iterators is exhausted.
//
//	Zip("abc", "123", "xyz") → ["a1x" "b2y" "c3z"]
//	Zip("abc", "12", "x") → ["a1x"]
//	Zip("abc", "") → []
//	Zip() → []
//
// See [Pairwise] for zipping two heterogenous sequences, or
// [ZipLongest] which stops only when all iterators are exhausted (and does not short-circuit).
//
// This function short-circuits and may not exhaust the provided iterator.
func Zip[T any](its ...Iterator[T]) Iterator[[]T] {
	if len(its) == 0 {
		return Empty[[]T]()
	}
	return &zipIterator[T]{its: its}
}

type zipLongestIterator[T any] struct {
	its  []Iterator[T]
	done uint64

	fill T
}

func (i *zipLongestIterator[T]) isDone(n int) bool { return i.done>>uint64(n)&1 != 0 }
func (i *zipLongestIterator[T]) setDone(n int)     { i.done |= 1 << uint64(n) }

func (i *zipLongestIterator[T]) Next() bool {
	for n, it := range i.its {
		if !i.isDone(n) && !it.Next() {
			i.setDone(n)
		}
	}

	return bits.OnesCount64(i.done) < len(i.its)
}

func (i *zipLongestIterator[T]) Get() []T {
	// TODO: Avoid allocating a slice for every call to Get
	r := make([]T, 0, len(i.its))
	for n, it := range i.its {
		if i.isDone(n) {
			r = append(r, i.fill)
		} else {
			r = append(r, it.Get())
		}
	}
	return r
}

func (i *zipLongestIterator[T]) Err() error {
	for _, it := range i.its {
		if err := it.Err(); err != nil {
			return err
		}
	}
	return nil
}

// ZipLongest returns slices of consecutive elements from all the iterators.
//
// Stops once all of the iterators are exhausted, even if one of the iterators stops with an error.
// Missing elements (from iterators which were exhausted before others were) are set to `fill`.
//
// Only up to 64 iterators are supported.
//
//	ZipLongest('-', "abc", "123", "xyz") → ["a1x" "b2y" "c3z"]
//	ZipLongest('-', "ab", "123", "x") → ["a1x" "b2-" "-3-"]
//	ZipLongest('-', "ab", "") → ["a-" "b-"]
//	ZipLongest(-1, [1 2], Error(someErr)) → [[1 -1] [2 -1]]
//	ZipLongest('-') → []
//
// See [PairwiseLongest] for zipping two heterogenous sequences, or
// [Zip] which stops once any of iterators stops.
func ZipLongest[T any](fill T, its ...Iterator[T]) Iterator[[]T] {
	if len(its) == 0 {
		return Empty[[]T]()
	} else if len(its) > 64 {
		panic(fmt.Sprintf("ZipLongest only supports up to 64 iterators, got %d", len(its)))
	}
	return &zipLongestIterator[T]{its: its, fill: fill}
}
